<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Experiment Recorder - Browser Example</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f5f5f5;
        }
        .container {
            background-color: white;
            padding: 30px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        .status {
            padding: 10px;
            margin: 10px 0;
            border-radius: 5px;
            font-weight: bold;
        }
        .status.idle { background-color: #e3f2fd; color: #1976d2; }
        .status.recording { background-color: #ffebee; color: #d32f2f; }
        .status.completed { background-color: #e8f5e8; color: #388e3c; }
        .button {
            background-color: #1976d2;
            color: white;
            border: none;
            padding: 10px 20px;
            margin: 5px;
            border-radius: 5px;
            cursor: pointer;
        }
        .button:hover {
            background-color: #1565c0;
        }
        .button:disabled {
            background-color: #ccc;
            cursor: not-allowed;
        }
        .log {
            background-color: #f8f9fa;
            border: 1px solid #e9ecef;
            padding: 10px;
            margin: 10px 0;
            border-radius: 5px;
            height: 200px;
            overflow-y: auto;
            font-family: monospace;
            font-size: 12px;
        }
        .metrics {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 10px;
            margin: 20px 0;
        }
        .metric-card {
            background-color: #f8f9fa;
            padding: 15px;
            border-radius: 5px;
            border: 1px solid #e9ecef;
        }
        .metric-value {
            font-size: 24px;
            font-weight: bold;
            color: #1976d2;
        }
        .calibration-target {
            position: absolute;
            width: 20px;
            height: 20px;
            background-color: #d32f2f;
            border-radius: 50%;
            display: none;
            transform: translate(-50%, -50%);
        }
        .gaze-indicator {
            position: absolute;
            width: 10px;
            height: 10px;
            background-color: #388e3c;
            border-radius: 50%;
            pointer-events: none;
            transform: translate(-50%, -50%);
            display: none;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>実験用画面録画・視線追跡システム</h1>
        
        <div id="status" class="status idle">
            待機中 - 実験を開始してください
        </div>

        <div>
            <input type="text" id="participantId" placeholder="参加者ID (例: P001)" value="P001">
            <input type="text" id="experimentType" placeholder="実験タイプ (例: web_browsing)" value="web_browsing_study">
        </div>

        <div>
            <button id="initBtn" class="button">初期化</button>
            <button id="calibrateBtn" class="button" disabled>キャリブレーション</button>
            <button id="startBtn" class="button" disabled>実験開始</button>
            <button id="stopBtn" class="button" disabled>実験停止</button>
        </div>

        <div class="metrics">
            <div class="metric-card">
                <div class="metric-value" id="gazeCount">0</div>
                <div>視線データ数</div>
            </div>
            <div class="metric-card">
                <div class="metric-value" id="recordingTime">0</div>
                <div>録画時間 (秒)</div>
            </div>
            <div class="metric-card">
                <div class="metric-value" id="calibrationAccuracy">-</div>
                <div>キャリブレーション精度</div>
            </div>
        </div>

        <div class="log" id="logArea"></div>
    </div>

    <!-- キャリブレーション用の点 -->
    <div id="calibrationTarget" class="calibration-target"></div>
    
    <!-- 視線位置表示 -->
    <div id="gazeIndicator" class="gaze-indicator"></div>

    <script type="module">
        // 実際のライブラリを使用する場合のコード例
        /*
        import {
            initializeExperiment,
            createSession,
            startExperiment,
            stopExperiment,
            calibrateEyeTracking,
            onGazeData,
            onSessionEvent,
            onCalibration
        } from './experiment-recorder.js';
        */
        
        // モック版の実装（デモ用）
        class MockExperimentRecorder {
            constructor() {
                this.isInitialized = false;
                this.isCalibrated = false;
                this.isRecording = false;
                this.sessionId = null;
                this.gazeDataCount = 0;
                this.recordingStartTime = null;
                this.calibrationAccuracy = 0.85;
                this.callbacks = {
                    onGazeData: null,
                    onSessionEvent: null,
                    onCalibration: null
                };
            }

            async initialize(config) {
                log('システムを初期化しています...');
                await new Promise(resolve => setTimeout(resolve, 1000));
                this.isInitialized = true;
                log('初期化完了');
            }

            async createSession(config) {
                this.sessionId = `session_${Date.now()}`;
                log(`セッションを作成しました: ${this.sessionId}`);
                return this.sessionId;
            }

            async calibrate() {
                log('キャリブレーションを開始します...');
                await this.runCalibration();
                this.isCalibrated = true;
                const result = {
                    accuracy: this.calibrationAccuracy,
                    points: 9,
                    timestamp: Date.now(),
                    success: true
                };
                if (this.callbacks.onCalibration) {
                    this.callbacks.onCalibration(result);
                }
                log(`キャリブレーション完了 (精度: ${this.calibrationAccuracy})`);
                return result;
            }

            async startExperiment() {
                log('実験を開始します...');
                this.isRecording = true;
                this.recordingStartTime = Date.now();
                this.startGazeDataSimulation();
                log('実験開始');
            }

            async stopExperiment() {
                log('実験を停止します...');
                this.isRecording = false;
                this.stopGazeDataSimulation();
                log('実験停止');
                return {
                    sessionId: this.sessionId,
                    exportData: {}
                };
            }

            onGazeData(callback) {
                this.callbacks.onGazeData = callback;
            }

            onSessionEvent(callback) {
                this.callbacks.onSessionEvent = callback;
            }

            onCalibration(callback) {
                this.callbacks.onCalibration = callback;
            }

            async runCalibration() {
                const target = document.getElementById('calibrationTarget');
                const positions = [
                    { x: 100, y: 100 },
                    { x: window.innerWidth / 2, y: 100 },
                    { x: window.innerWidth - 100, y: 100 },
                    { x: 100, y: window.innerHeight / 2 },
                    { x: window.innerWidth / 2, y: window.innerHeight / 2 },
                    { x: window.innerWidth - 100, y: window.innerHeight / 2 },
                    { x: 100, y: window.innerHeight - 100 },
                    { x: window.innerWidth / 2, y: window.innerHeight - 100 },
                    { x: window.innerWidth - 100, y: window.innerHeight - 100 }
                ];

                for (const pos of positions) {
                    target.style.left = pos.x + 'px';
                    target.style.top = pos.y + 'px';
                    target.style.display = 'block';
                    await new Promise(resolve => setTimeout(resolve, 1000));
                }
                
                target.style.display = 'none';
            }

            startGazeDataSimulation() {
                this.gazeInterval = setInterval(() => {
                    if (!this.isRecording) return;
                    
                    const gazeData = {
                        screenX: Math.random() * window.innerWidth,
                        screenY: Math.random() * window.innerHeight,
                        confidence: 0.8 + Math.random() * 0.2,
                        timestamp: Date.now()
                    };
                    
                    this.gazeDataCount++;
                    if (this.callbacks.onGazeData) {
                        this.callbacks.onGazeData(gazeData);
                    }
                }, 16); // 約60Hz
            }

            stopGazeDataSimulation() {
                if (this.gazeInterval) {
                    clearInterval(this.gazeInterval);
                }
            }
        }

        // UI要素の取得
        const statusDiv = document.getElementById('status');
        const logArea = document.getElementById('logArea');
        const gazeCountDiv = document.getElementById('gazeCount');
        const recordingTimeDiv = document.getElementById('recordingTime');
        const calibrationAccuracyDiv = document.getElementById('calibrationAccuracy');
        const gazeIndicator = document.getElementById('gazeIndicator');

        const initBtn = document.getElementById('initBtn');
        const calibrateBtn = document.getElementById('calibrateBtn');
        const startBtn = document.getElementById('startBtn');
        const stopBtn = document.getElementById('stopBtn');

        const participantIdInput = document.getElementById('participantId');
        const experimentTypeInput = document.getElementById('experimentType');

        // 実験レコーダーのインスタンス
        const recorder = new MockExperimentRecorder();

        // ログ表示関数
        function log(message) {
            const timestamp = new Date().toLocaleTimeString();
            logArea.innerHTML += `[${timestamp}] ${message}\n`;
            logArea.scrollTop = logArea.scrollHeight;
        }

        // 状態更新関数
        function updateStatus(status, message) {
            statusDiv.className = `status ${status}`;
            statusDiv.textContent = message;
        }

        // メトリクス更新関数
        function updateMetrics() {
            gazeCountDiv.textContent = recorder.gazeDataCount;
            
            if (recorder.recordingStartTime) {
                const elapsed = Math.floor((Date.now() - recorder.recordingStartTime) / 1000);
                recordingTimeDiv.textContent = elapsed;
            }
            
            calibrationAccuracyDiv.textContent = recorder.isCalibrated ? 
                recorder.calibrationAccuracy.toFixed(3) : '-';
        }

        // イベントリスナーの設定
        recorder.onGazeData((gazeData) => {
            // 視線位置の表示
            gazeIndicator.style.left = gazeData.screenX + 'px';
            gazeIndicator.style.top = gazeData.screenY + 'px';
            gazeIndicator.style.display = 'block';
            
            // 一定時間後に非表示
            setTimeout(() => {
                gazeIndicator.style.display = 'none';
            }, 100);
        });

        recorder.onSessionEvent((event) => {
            log(`イベント: ${event.type}`);
        });

        recorder.onCalibration((result) => {
            log(`キャリブレーション結果: 精度 ${result.accuracy}`);
        });

        // ボタンのイベントハンドラー
        initBtn.addEventListener('click', async () => {
            try {
                initBtn.disabled = true;
                updateStatus('idle', '初期化中...');
                
                await recorder.initialize({
                    eyeTrackingServerUrl: 'ws://localhost:8080'
                });
                
                calibrateBtn.disabled = false;
                updateStatus('idle', '初期化完了 - キャリブレーションを実行してください');
            } catch (error) {
                log(`初期化エラー: ${error.message}`);
                initBtn.disabled = false;
            }
        });

        calibrateBtn.addEventListener('click', async () => {
            try {
                calibrateBtn.disabled = true;
                updateStatus('idle', 'キャリブレーション中...');
                
                await recorder.createSession({
                    participantId: participantIdInput.value,
                    experimentType: experimentTypeInput.value
                });
                
                await recorder.calibrate();
                
                startBtn.disabled = false;
                updateStatus('idle', 'キャリブレーション完了 - 実験を開始できます');
            } catch (error) {
                log(`キャリブレーションエラー: ${error.message}`);
                calibrateBtn.disabled = false;
            }
        });

        startBtn.addEventListener('click', async () => {
            try {
                startBtn.disabled = true;
                updateStatus('recording', '実験実行中...');
                
                await recorder.startExperiment();
                
                stopBtn.disabled = false;
                
                // メトリクスの定期更新
                updateInterval = setInterval(updateMetrics, 1000);
                
            } catch (error) {
                log(`実験開始エラー: ${error.message}`);
                startBtn.disabled = false;
            }
        });

        stopBtn.addEventListener('click', async () => {
            try {
                stopBtn.disabled = true;
                updateStatus('completed', '実験停止中...');
                
                await recorder.stopExperiment();
                
                if (updateInterval) {
                    clearInterval(updateInterval);
                }
                
                initBtn.disabled = false;
                updateStatus('completed', '実験完了');
                
            } catch (error) {
                log(`実験停止エラー: ${error.message}`);
                stopBtn.disabled = false;
            }
        });

        // 初期化
        log('システムが準備完了しました。');
        updateMetrics();
    </script>
</body>
</html>